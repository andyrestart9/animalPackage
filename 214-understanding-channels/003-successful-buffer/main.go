package main

import "fmt"

func main() {
	c := make(chan int, 1) // 建立一個容量為 1 的緩衝 channel

	c <- 42 // 將 42 存入 channel，因為 channel 是空的，所以不會阻塞

	fmt.Println(<-c) // 從 channel 中取出 42 並印出
}

/*
為什麼不會阻塞或死鎖：

緩衝區的作用：
帶緩衝區的 channel 可以儲存指定數量的資料。這裡緩衝區大小為 1，表示可以先存入一個值，而不需要立即有接收者來接收。

send 操作不阻塞：
當執行 c <- 42 時，因為 channel 目前是空的，所以 42 會被存入緩衝區，操作立即成功，不會等待接收者。

接收操作可以順利取得值：
接下來的 fmt.Println(<-c) 則從 channel 取得之前送入的 42，並印出來。因為 channel 已經有值，所以接收操作不會阻塞。
*/

/*
盡量使用 unbuffered channels 而非 buffered channels，原因有以下幾點：

嚴格同步的保證：
使用 unbuffered channels 意味著每一次的送出操作必須等待對應的接收操作，這樣能夠確保程式中資料的傳遞是同步進行的。換句話說，資料從送出到被接收之間形成了一個「交織」的連結，這樣可以降低出錯的風險，並使邏輯更容易推理。

明確的控制流：
當你使用 unbuffered channels 時，程式碼必須明確地安排好誰在送資料、誰在收資料，這種「鎖定」機制迫使你在設計時思考並確保所有操作都有配對，這有助於發現潛在的同步問題。

避免潛在隱患：
雖然 buffered channels 可以讓生產者和消費者解耦，從而在某些情況下提升效能，但它們也容易讓你忽略或掩蓋程式中不恰當的同步邏輯。用 unbuffered channels 則可以讓你及早發現設計上的漏洞，因為任何未能及時進行的接收操作都會立即導致阻塞，從而迫使你修正問題。

總結來說：
盡量避免依賴 buffered channels，除非確有必要。優先使用 unbuffered channels，讓你的程式在送出與接收之間始終存在一個明確且同步的交接點，這樣可以使程式的同步行為更直觀，降低錯誤發生的可能。
*/